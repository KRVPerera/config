#+title: Office
#+author: KRV Perera
#+email: rukshan.viduranga@gmail.com

=ox-twbs=

* TOP
:PROPERTIES:
:CUSTOM_ID: TOP
:END:
[[file:krvperera.org][HOME]] [[file:linux.org][LINUX]] [[file:EldenRing.org][Elden Ring]] [[file:country.org][Country]] [[file:org-mode-reference-in.org][HotKeys]] [[#BOTTOM][BOTTOM]]

* Office tasks

** TODO closure annotations - fields
DEADLINE: <2022-05-08 ඉ>
:LOGBOOK:
CLOCK: [2022-05-08 ඉ 11:30]
:END:
#+BEGIN: clocktable :scope subtree :maxlevel 2
#+CAPTION: Clock summary at [2022-05-08 ඉ 11:31]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:00* |
#+END:


Refactoring is done. Some changes done to process arrow expression is breaking the build. Target is to first fix the annotation fields.
Current problem is with the function related to the field is not added in a context or in a body.

 .

*** DEBUG
    classDef    : class $annonType$_1 { string xField = hosty; }
    function    : annot_func$_0 is function (LAMDA)
    mapLiteral  : {HSCsa: {hostRecField: hosty}.cloneReadOnly()}

**** Fields
***** attachments
HSCfa       : expr ( {hostRecField: hosty} )

function    : [LAMBDA] $annot_func$_1([]) (map) Body: {}
mapLiteral  : "{HSCfa: {hostRecField: hosty}.cloneReadOnly()}"

mapLiteral  :
    HSCsa: {hostRecField: hosty}.cloneReadOnly()
    $field$.xField: $annot_func$_1()



** TODO closure start actions
DEADLINE: <2022-05-08 Sun>
** code reviews
*** dulmina

**** TODO [[https://github.com/ballerina-platform/ballerina-lang/pull/36044][Fix NPE when variable of undefined type used in from and join clauses]]

**** TODO spec conformance test

*** gimantha

**** TODO COMMENT PR I need to review

[[https://github.com/ballerina-platform/ballerina-lang/pull/35960][PR Lin]]
added a comment checking the situation with `var`

DEADLINE: <2022-05-07 Sat>

*** lochana

**** TODO isSameType [[https://github.com/ballerina-platform/ballerina-lang/pull/35925][pr]]

#+BEGIN_SRC java
      TypePair pair = new TypePair(source, target);
      if (unresolvedTypes.contains(pair)) {
          return true; // THIS IS TRUE FOR CYCLIC TYPES, NOT FOR OTHER TYPES.
      }
      unresolvedTypes.add(pair);
      BTypeVisitor<BType, Boolean> sameTypeVisitor = new BSameTypeVisitor(unresolvedTypes);
      boolean result = target.accept(sameTypeVisitor, source);
      if (result) {
          return true;
      }
      unresolvedTypes.remove(pair);
      return false;
#+END_SRC

#+BEGIN_SRC ruby
def fact(n)
  if n== 0
    1
  else
    n * fact(n - 1)
  end
end
fact(5)
#+END_SRC

#+RESULTS:
: 120

* BOTTOM
:PROPERTIES:
:CUSTOM_ID: BOTTOM
:END:
[[#TOP][TOP]]
